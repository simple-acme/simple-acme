using PKISharp.WACS.Clients.DNS;
using PKISharp.WACS.Plugins.Base.Capabilities;
using PKISharp.WACS.Plugins.Interfaces;
using PKISharp.WACS.Plugins.ValidationPlugins.Dns;
using PKISharp.WACS.Services;
using System;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;

namespace PKISharp.WACS.Plugins.ValidationPlugins;

/// <summary>
/// This class is the heart of the plugin, it implements the functions
/// required to create and delete DNS records for challengeDomain validation.
/// 
/// This IPlugin.Plugin1 decorator registers the plugin with the WACS 
/// framework, Its generic parameters are:
/// 
/// - WebnamesArguments: The arguments class that defines the command line options for the plugin
/// - WebnamesOptions: The options class that holds the configuration for the plugin as stored on disk
/// - WebnamesOptionsFactory: The factory class that creates instances of WebnamesOptions during renewal setup
/// - WebnamesJson: JSON serialization helper for WebnamesOptions, required for saving and loading options
/// - DnsValidationCapability: The capability that indicates this plugin can perform DNS validation
/// 
/// Other parameters:
/// - GUID:                A unique identifier for the plugin:
/// - Trigger:             A human-readable name for the plugin, shown in the WACS UI and used 
///                        as command line option (e.g. --validation Webnames)
/// - Description:         A short description of what the plugin does, shown in the WACS UI
/// - External:            Indicates that this plugin is an external plugin, meaning it is not
///                        part of the core WACS distribution
/// - Provider:            Use only if the DNS service has a strong seperate brand from its 
///                        parent company, e.g. "Route53" has provider "Amazon AWS".
/// </summary>
/// <param name="options">The options as stored in the JSON for the renewal</param>
/// <param name="dnsClient">Required for the base class to do DNS lookups</param>
/// <param name="log">Allow you to write to the logger</param>
/// <param name="settings">Effective settings.json settings for the renewal</param>
/// <param name="proxy">Used by base class to generate HttpClient with proper proxy settings</param>
/// <param name="ssm">Can be used to access secrets from the secret manager</param>
/// <remarks>Based on PKISharp.WACS.Plugins.ValidationPlugins.Reference.</remarks>
[IPlugin.Plugin1<
    WebnamesOptions, WebnamesOptionsFactory,
    DnsValidationCapability, WebnamesJson, WebnamesArguments>
    ("86C8D86B-2069-4048-9BF1-FADB07E84D61",
    "Webnames", "Create verification DNS TXT records via Webnames.ca REST API",
    External = true, Provider = null)]
internal class Webnames(
    WebnamesOptions options,
    LookupClientProvider dnsClient,
    ILogService log,
    ISettings settings,
    IProxyService proxy,
    SecretServiceManager ssm,
    DomainParseService domainParser) : DnsValidation<Webnames, WebnamesClient>(dnsClient, log, settings, proxy)
{
    /// <summary>
    /// Create a new instance of your DNS accessor
    /// </summary>
    /// <param name="httpClient">
    /// HttpClient generated by simple-acme, this client is 
    /// already hooked up to the logger, respects the users 
    /// proxy settings and identifies itself as the 
    /// current simple-acme version using the User-Agent header
    /// </param>
    /// <returns></returns>
    protected override async Task<WebnamesClient> CreateClient(HttpClient httpClient)
    {
        var clientId = options.APIUsername ?? "";
        var clientSecret = await ssm.EvaluateSecret(options.APIKey) ?? "";
        return new WebnamesClient(httpClient, clientId, clientSecret, options.APIOverrideBaseURL);
    }

    /// <summary>
    /// Create a DNS record required by the ACME server
    /// </summary>
    public override async Task<bool> CreateRecord(DnsValidationRecord record)
    {
        try
        {
            var zone = domainParser.GetRegisterableDomain(record.Authority.Domain);
            if (zone == null)
            {
                _log.Error("Unable to find zone for {challengeDomain}", record.Authority.Domain);
                return false;
            }

            // Get client (cached) and create the record
            var client = await GetClient();
            await client.CreateTxtRecord(zone, record.Authority.Domain, record.Value);
            return true;
        }
        catch (Exception ex)
        {
            _log.Error(ex, "Unhandled exception when attempting to create record");
            return false;
        }
    }

    /// <summary>
    /// Delete the TXT record after validation has been completed
    /// </summary>
    public override async Task DeleteRecord(DnsValidationRecord record)
    {
        try
        {
            var zone = domainParser.GetRegisterableDomain(record.Authority.Domain);
            if (zone == null)
            {
                _log.Warning("Unable to find zone for {challengeDomain}", record.Authority.Domain);
                return;
            }

            var client = await GetClient();
            await client.DeleteTxtRecord(zone, record.Authority.Domain, record.Value);
        }
        catch (Exception ex)
        {
            _log.Warning(ex, $"Unable to delete record");
        }
    }
}
